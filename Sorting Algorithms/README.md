## 常用排序算法

- [插入排序](./InsertionSort.h)

插入排序是一种最简单的排序方法，它的基本思想是**将一个记录插入到已经排好序的有序表中**，得到一个记录数增`1`的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

- [基于二分查找的插入排序](./BInsertionSort.h)

插入排序的改进版本，由于前面已经形成了一个有序数组，所以可以使用**二分查找**的方式寻找下一个元素插入的位置。相比于普通的插入排序，改进后的版本减少了比较次数，但是数量级没有改变，`O(n^2)`.

- [冒泡排序](./BubbleSort.h)

冒泡排序(`Bubble Sort`)是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行，直到没有再需要交换，此时该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

冒泡排序对`n`个项目需要`O(n^2)`的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。

- [选择排序](./SelectionSort.h)

选择排序(`Selection sort`)是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小(大)元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。

- [归并排序](./MergeSort.h)

归并排序(`Merge Sort`)是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用**分治法**(`Divide and Conquer`)的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。

- [快速排序](./QuickSort.h)

快速排序使用**分治法**(`Divide and conquer`)策略来把一个序列(`list`)分为较小和较大的`2`个子序列，然后递归地排序两个子序列。

该算法最早由东尼·霍尔提出。在平均状况下，排序`n`个项目要`O(nlogn)`次比较。在最坏状况下则需要`O(n^2)`次比较，但这种状况并不常见。

- [堆排序](./HeapSort.h)

堆排序(`Heapsort`)是指利用**堆**这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时子节点的键值或索引总是小于(或者大于)它的父节点。

以升序排序说明，堆排序首先把数组转换成最大堆(`Max-Heap Heap`)，然后重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并调整使得让残余的堆维持最大堆性质。

- [希尔排序](./ShellSort.h)

希尔排序(`Shell's Sort`)是插入排序的一种又称“**缩小增量排序**”(`Diminishing Increment Sort`)，是直接插入排序算法的一种更高效的改进版本。希尔排序是**非稳定**排序算法。该方法因`D.L.Shell`于`1959`年提出而得名。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至`1`时，整个文件恰被分成一组，算法便终止。

- [计数排序](./CountSort.h)

计数排序(`Counting sort`)是一种稳定的线性时间排序算法。该算法于`1954`年由`Harold H. Seward`提出。计数排序使用一个**额外的数组**`C`，其中第`i`个元素是待排序数组`A`中值等于`i`的元素的个数。然后根据数组`C`来将`A`中的元素排到正确的位置。值得注意的是，这种排序算法**不基于比较**。

- 基数排序([int版](./RadixSort_int.h)、[string版](./RadixSort_string.h))

基数排序(`Radix sort`)是一种非比较型整数排序算法，其原理是**将整数按位数切割成不同的数字，然后按每个位数分别比较**。由于整数也可以表达字符串和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到`1887`年赫尔曼·何乐礼在打孔卡片制表机(`Tabulation Machine`)上的贡献。

- [排序算法测试文件](./sort_test.cpp)

用于测试所有排序算法已经比较它们的耗时。
