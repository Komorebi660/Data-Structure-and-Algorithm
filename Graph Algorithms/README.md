## 经典图论算法

- [Prim最小生成树](./Prim.cpp)

`Prim`算法是一种最小生成树(`MST`)算法，它定义了一个集合`S`表示当前在`MST`中的点，算法每次迭代选择从集合`S`到`V-S`中选择边权最小的那条边加入到`MST`中，并把对应顶点加入到`S`中，直到`S`包含了图中的所有顶点(如果图连通的话)。

该算法涉及到大量的`EXTRACT-MIN`和`DECREASE-KEY`的操作，可使用**斐波那契堆**进行优化。

另外，还有一种`MST`算法——`Kruskal`算法，该算法涉及到**不相交集合**这一数据结构。

- [Dijkstra最短路径](./Dijkstra.cpp)

`Dijkstra`算法是经典的单源最短路径算法，它为每个节点维护了一个最短路径估计值`d`，同时定义了一个集合`S`表示当前已找到最短路径的点，算法每次迭代从集合`V-S`中选择`d`最小的那个顶点加入到集合`S`中，表明该节点的最短路径已经找到，然后对`V-S`的点的`d`值进行更新。迭代直到所有点的最短路径已经求得。

该算法涉及到大量的`EXTRACT-MIN`和`DECREASE-KEY`的操作，可使用**斐波那契堆**进行优化。

该算法的缺陷是**不支持负边**，若要支持负边，可以选择时间复杂度较高的`Bellman-Ford`算法。若要求解所有节点之间的最短路径，则需要利用动态规划的思想进行处理，经典的算法有`Floyd-Warshall`算法、`Johnson`算法等。

- [Dinic最大流](./Dinic.cpp)

几乎所有的最大流问题都可以转化为单源最大流问题(即只有一个源和一个汇)，`Dinic`算法相较于`Ford-Fulkerson`算法进行了优化，给节点通过`BFS`打上标签，避免了一些极端情况造成的多次迭代。

- [连通性问题](./SimpleConnectGraph.cpp)

无向图的连通性可以通过`BFS`来判断，有向图的连通性主要分为**强连通**与**弱连通**。

强连通是指该连通片中任意两个节点互相可达，可以通过`Tarjan`算法求出所有的强连通片。

弱连通是指该连通片中任意两个节点`u`、`v`，要么`u`可达`v`，要么`v`可达`u`，注意到强连通一定弱连通，所以我们通过`Tarjan`算法求出所有的强连通片，然后将强连通片缩点构造一个新的图`G`，该图是一个`DAG`，然后利用拓扑排序的方法根据每个顶点的入度判断单连通性。如果要求出最大的单连通片，则可以将拓扑排序替换成`DFS`进行计算。